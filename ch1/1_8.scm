(load "1_7.scm")

(define (Lagrangian->energy L)
  (let ((P ((partial 2) L)))
    (- (* P velocity) L)))

(define ((T3-spherical m) state)
  (let ((q (coordinate state))
        (qdot (velocity state)))
    (let ((r (ref q 0))
          (theta (ref q 1))
          (rdot (ref qdot 0))
          (thetadot (ref qdot 1))
          (phidot (ref qdot 2)))
      (* 1/2 m
         (+ (square rdot)
            (square (* r thetadot))
            (square (* r (sin theta) phidot)))))))

(define (L3-central m Vr)
  (define (Vs state)
    (let ((r (ref (coordinate state) 0)))
      (Vr r)))
  (- (T3-spherical m) Vs))

(define ((ang-mom-z m) rectangular-state)
  (let ((xyz (coordinate rectangular-state))
        (v (velocity rectangular-state)))
    (ref (cross-product xyz (* m v)) 2)))

(define (s->r spherical-state)
  (let ((q (coordinate spherical-state)))
    (let ((r (ref q 0))
          (theta (ref q 1))
          (phi (ref q 2)))
      (let ((x (* r (sin theta) (cos phi)))
            (y (* r (sin theta) (sin phi)))
            (z (* r (cos theta))))
        (up x y z)))))

(define ((L0 m V) local)
  (let ((t (time local))
        (q (coordinates local))
        (v (velocities local)))
    (- (* 1/2 m (square v)) (V t q))))

(define ((V a GM0 GM1 m) t xy)
  (let ((Omega (sqrt (/ (+ GM0 GM1) (expt a 3))))
        (a0 (* (/ GM1 (+ GM0 GM1)) a))
        (a1 (* (/ GM0 (+ GM0 GM1)) a)))
    (let ((x (ref xy 0)) (y (ref xy 1))
          (x0 (* -1 a0 (cos (* Omega t))))
          (y0 (* -1 a0 (sin (* Omega t))))
          (x1 (* +1 a1 (cos (* Omega t))))
          (y1 (* +1 a1 (sin (* Omega t)))))
      (let ((r0
              (sqrt (+ (square (- x x0)) (square (- y y0)))))
            (r1
              (sqrt (+ (square (- x x1)) (square (- y y1))))))
        (- (+ (/ (* GM0 m) r0) (/ (* GM1 m) r1)))))))

(define ((LR3B m a GM0 GM1) local)
  (let ((q (coordinates local))
        (qdot (velocities local))
        (Omega (sqrt (/ (+ GM0 GM1) (expt a 3))))
        (a0 (* (/ GM1 (+ GM0 GM1)) a))
        (a1 (* (/ GM0 (+ GM0 GM1)) a)))
    (let ((x (ref q 0)) (y (ref q 1))
          (xdot (ref qdot 0)) (ydot (ref qdot 1)))
      (let ((r0 (sqrt (+ (square (+ x a0)) (square y))))
            (r1 (sqrt (+ (square (- x a1)) (square y)))))
        (+ (* 1/2 m (square qdot))
           (* 1/2 m (square Omega) (square q))
           (* m Omega (- (* x ydot) (* xdot y)))
           (/ (* GM0 m) r0) (/ (* GM1 m) r1))))))


(define ((LR3B1 m a0 a1 Omega GM0 GM1) local)
  (let ((q (coordinates local))
        (qdot (velocities local)))
    (let ((x (ref q 0)) (y (ref q 1))
          (xdot (ref qdot 0)) (ydot (ref qdot 1)))
      (let ((r0 (sqrt (+ (square (+ x a0)) (square y))))
            (r1 (sqrt (+ (square (- x a1)) (square y)))))
        (+ (* 1/2 m (square qdot))
           (* 1/2 m (square Omega) (square q))
           (* m Omega (- (* x ydot) (* xdot y)))
           (/ (* GM0 m) r0) (/ (* GM1 m) r1))))))

(define (F-tilde angle-x angle-y angle-z)
  (compose (Rx angle-x) (Ry angle-y) (Rz angle-z) coordinate))

(define ((L-central-rectangular m U) state)
  (let ((q (coordinate state))
        (v (velocity state)))
    (- (* 1/2 m (square v))
       (U (sqrt (square q))))))

(define the-Noether-integral
  (let ((L (L-central-rectangular
             'm (literal-function 'U))))
    (* ((partial 2) L) ((D F-tilde) 0 0 0))))
